diff --git a/config.yml b/config.yml
index 76eefad..abd46a7 100644
--- a/config.yml
+++ b/config.yml
@@ -3,6 +3,7 @@ defaults:
   app:
     component:        hooks
     hookTableName:    !env HOOK_TABLE_NAME
+    queuesTableName:  !env QUEUE_TABLE_NAME
     publishMetaData:  !env:bool PUBLISH_METADATA
     scheduler:
       pollingDelay:   60000
@@ -42,6 +43,12 @@ defaults:
       secretAccessKey:  !env AWS_SECRET_ACCESS_KEY
       region:           us-west-2
       apiVersion:       2014-01-01
+  pulse:
+    username:       !env PULSE_USERNAME
+    password:       !env PULSE_PASSWORD
+    hostname:       !env PULSE_HOSTNAME
+    vhost:          !env PULSE_VHOST
+
 
 production:
   server:
@@ -52,6 +59,7 @@ test:
   app:
     component:        hooks-tests
     hookTableName:    HooksTestTable2
+    queuesTableName:  QueueTestTable
     publishMetaData:  false
     scheduler:
       pollingDelay:   5000
@@ -67,3 +75,5 @@ test:
     env:              development
     forceSSL:         false
     trustProxy:       false
+  pulse:
+    namespace:        'taskcluster-fake'
diff --git a/package.json b/package.json
index 61b7d9b..195affd 100644
--- a/package.json
+++ b/package.json
@@ -25,6 +25,7 @@
     "json-e": "^2.3.5",
     "lodash": "^4.17.4",
     "promise": "^8.0.1",
+    "pulse-publisher": "^10.0.1",
     "taskcluster-client": "^11.0.0",
     "taskcluster-lib-api": "^12.0.2",
     "taskcluster-lib-app": "10.0.0",
@@ -32,6 +33,7 @@
     "taskcluster-lib-docs": "^10.0.0",
     "taskcluster-lib-loader": "10.0.0",
     "taskcluster-lib-monitor": "^10.0.0",
+    "taskcluster-lib-pulse": "^2.0.2",
     "taskcluster-lib-urls": "^10.0.0",
     "taskcluster-lib-validate": "^11.0.2",
     "typed-env-config": "^2.0.0"
diff --git a/schemas/v1/bindings.yml b/schemas/v1/bindings.yml
new file mode 100644
index 0000000..5038435
--- /dev/null
+++ b/schemas/v1/bindings.yml
@@ -0,0 +1,18 @@
+$schema: http://json-schema.org/draft-06/schema#
+title:   "List of Bindings"
+type: "array"
+properties:
+  items:
+    title:              "Binding"
+    description: |
+      Exchange and RoutingKeyPattern for each binding
+    type:               object
+    properties:
+      exchange:
+        type:           string
+      routingKeyPattern:
+        type:           string
+    additionalProperties:     false
+    required:
+      - exchange
+      - routingKeyPattern
\ No newline at end of file
diff --git a/schemas/v1/create-hook-request.yml b/schemas/v1/create-hook-request.yml
index b8ff6b1..11a63be 100644
--- a/schemas/v1/create-hook-request.yml
+++ b/schemas/v1/create-hook-request.yml
@@ -7,6 +7,7 @@ properties:
   hookGroupId:            {$const: hookGroupId}
   hookId:                 {$const: hookId}
   metadata:               {$ref: "hook-metadata.json#"}
+  bindings:               {$ref:  "bindings.json#"}
   schedule:
     # It would be prettier with:
     # {$ref: "http://schemas.taskcluster.net/hooks/v1/schedule.json#"}
diff --git a/schemas/v1/hook-definition.yml b/schemas/v1/hook-definition.yml
index f43313c..403dd29 100644
--- a/schemas/v1/hook-definition.yml
+++ b/schemas/v1/hook-definition.yml
@@ -7,6 +7,7 @@ properties:
   hookGroupId:            {$const: hookGroupId}
   hookId:                 {$const: hookId}
   metadata:               {$ref: "hook-metadata.json#"}
+  bindings:               {$ref:  "bindings.json#"}
   schedule:
     description: |
       Definition of the times at which a hook will result in creation of a task.
diff --git a/schemas/v1/pulse-hook-changed-message.yml b/schemas/v1/pulse-hook-changed-message.yml
new file mode 100644
index 0000000..e784974
--- /dev/null
+++ b/schemas/v1/pulse-hook-changed-message.yml
@@ -0,0 +1,18 @@
+$schema:  http://json-schema.org/draft-06/schema#
+title:        "Hook Changed Message"
+description: |
+  Message reporting that a hook has changed
+type:         object
+properties:
+  hookGroupId:
+    description: |
+      `hookGroupId` of the hook that was changed
+    type:                 string
+  hookId:
+    description: |
+      `hookId` of the hook that was changed
+    type:                 string
+additionalProperties: true
+required:
+  - hookId
+  - hookGroupId
\ No newline at end of file
diff --git a/src/data.js b/src/data.js
index 09429f8..b815b92 100644
--- a/src/data.js
+++ b/src/data.js
@@ -168,6 +168,7 @@ Hook.prototype.definition = function() {
   return Promise.resolve({
     hookId:       this.hookId,
     hookGroupId:  this.hookGroupId,
+    bindings:     this.bindings,
     metadata:     _.cloneDeep(this.metadata),
     task:         _.cloneDeep(this.task),
     schedule:     _.cloneDeep(this.schedule),
@@ -175,5 +176,19 @@ Hook.prototype.definition = function() {
   });
 };
 
-// export Hook
+const Queues = Entity.configure({
+  version:              1,
+  partitionKey:         Entity.keys.StringKey('hookGroupId'),
+  rowKey:               Entity.keys.StringKey('hookId'),
+  signEntities:         true,
+  properties:           {
+    hookGroupId:        Entity.types.String,
+    hookId:             Entity.types.String,
+    queueName:          Entity.types.String,
+    bindings:           Entity.types.JSON,
+  },
+});
+
+// export Hook and Queues
 exports.Hook = Hook;
+exports.Queues = Queues;
diff --git a/src/exchanges.js b/src/exchanges.js
new file mode 100644
index 0000000..0deef06
--- /dev/null
+++ b/src/exchanges.js
@@ -0,0 +1,108 @@
+let Exchanges = require('pulse-publisher');
+
+/** Declaration of exchanges used by hooks  */
+let exchanges = new Exchanges({
+  title:       'Exchanges to manage hooks',
+  projectName: 'taskcluster-hooks',
+  serviceName: 'hooks',
+  version: 'v1',
+  description: [
+    'The hooks service, typically available at `hooks.taskcluster.net`',
+    'is responsible for creating tasks at specific times or in .',
+    'response to webhooks and API calls.Using this exchange allows us',
+    'to make hooks which repsond to particular pulse messages',
+    '',
+    'These exchanges provide notifications when a hook is created, updated',
+    'or deleted. This is so that the listener running in a different hooks ',
+    'process at the other end can direct another listener specified by', 
+    '`hookGroupId` and `hookId` to synchronize its bindings. But you are of',
+    'course welcome to use these for other purposes, monitoring changes for example.',
+  ].join(''),
+});
+
+// Export exchanges
+module.exports = exchanges;
+
+/** Build common routing key construct for `exchanges.declare` */
+var buildCommonRoutingKey = (options) => {
+  return [
+    {
+      name:             'reserved',
+      summary:          'Space reserved for future routing-key entries, you ' +
+                        'should always match this entry with `#`. As ' +
+                        'automatically done by our tooling, if not specified.',
+      multipleWords:    true,
+      maxSize:          10,
+    },
+  ];
+};
+
+/** Build an AMQP compatible message from a message */
+var commonMessageBuilder = function(message) {
+  return message;
+};
+
+/** Build a routingKey from message */
+/** Empty now, might be useful in the future */
+/** when this comment should be removed */
+var commonRoutingKeyBuilder = function(message, routing) {
+  return '';
+};
+
+/** Build list of routing keys to CC */
+/** Empty now, might be useful in the future */
+/** when this comment should be removed */
+var commonCCBuilder = function(message, routes) {
+  return [];
+};
+
+// Hook created exchange
+exchanges.declare({
+  exchange: 'hook-created',
+  name:     'hookCreated',
+  title:    'Hook Created Messages',
+  description: [
+    'Whenever the api receives a request to create a',
+    'pulse based hook, a message is posted to this exchange and',
+    'the receiver creates a listener with the bindings, to create a task',
+  ].join(''),
+  schema:   'pulse-hook-changed-message.json#',
+  messageBuilder: commonMessageBuilder,
+  routingKey: buildCommonRoutingKey(),
+  routingKeyBuilder: commonRoutingKeyBuilder,
+  CCBuilder: commonCCBuilder,
+});
+
+// Hook updated exchange
+exchanges.declare({
+  exchange: 'hook-updated',
+  name:     'hookUpdated',
+  title:    'Hook Updated Messages',
+  description: [
+    'Whenever the api receives a request to update a',
+    'pulse based hook, a message is posted to this exchange and',
+    'the receiver updates the listener associated with that hook.',
+  ].join(''),
+  schema:   'pulse-hook-changed-message.json#',
+  messageBuilder: commonMessageBuilder,
+  routingKey: buildCommonRoutingKey(),
+  routingKeyBuilder: commonRoutingKeyBuilder,
+  CCBuilder: commonCCBuilder,
+});
+
+// Hook deleted exchange
+exchanges.declare({
+  exchange: 'hook-deleted',
+  name:     'hookDeleted',
+  title:    'Hook Deleted Messages',
+  description: [
+    'Whenever the api receives a request to delete a',
+    'pulse based hook, a message is posted to this exchange and',
+    'the receiver deletes the listener associated with that hook.',
+  ].join(''),
+  schema:   'pulse-hook-changed-message.json#',
+  messageBuilder: commonMessageBuilder,
+  routingKey: buildCommonRoutingKey(),
+  routingKeyBuilder: commonRoutingKeyBuilder,
+  CCBuilder: commonCCBuilder,
+});
diff --git a/src/listeners.js b/src/listeners.js
new file mode 100644
index 0000000..1dab856
--- /dev/null
+++ b/src/listeners.js
@@ -0,0 +1,197 @@
+const assert = require('assert');
+const debug = require('debug')('listeners');
+const pulse = require('taskcluster-lib-pulse');
+const _ = require('lodash');
+
+/**
+ * Create pulse client and consumers to trigger hooks with pulse messages 
+ *
+ * options:
+ * {
+ *   Hook:               // Azure tables for hooks
+ *   taskcreator:        // A TaskCreator instance
+ *   client:            // A tc-lib-pulse client instance
+ * }
+ */
+
+class HookListeners {
+  constructor(options) {
+    assert(options.client, 'tc-lib-pulse client must be provided');
+
+    this.taskcreator = options.taskcreator;
+    this.Hook = options.Hook;
+    this.Queues = options.Queues;
+    this.client = options.client;
+    this.pulseHookChangedListener = null;
+    this.listeners = null;
+    this._reconcileDone = Promise.resolve();
+  }
+
+  /**
+   * Setup a new pulse client using the credentials
+   * Additionally create pulse consumers for the exchanges - 
+   * `hook-created, `hook-updated` and  `hook-deleted`
+  */
+  async setup() {
+    debug('Setting up the listeners');
+    assert(this.listeners === null, 'Cannot setup twice');
+
+    const client = this.client;
+    let consumer = await pulse.consume({
+      client,
+      bindings: [{
+        exchange: 'exchange/taskcluster-hooks/v1/hook-created',
+        routingKeyPattern: '#',
+      }, {
+        exchange: 'exchange/taskcluster-hooks/v1/hook-updated',
+        routingKeyPattern: '#',
+      }, {
+        exchange: 'exchange/taskcluster-hooks/v1/hook-deleted',
+        routingKeyPattern: '#',
+      }],
+      queueName: 'hookChanged',
+      maxLength : 50,
+    }, (msg) => this.reconcileConsumers()
+    );
+    debug('Listening to hook exchanges');
+    this.pulseHookChangedListener = consumer;
+    this.listeners = [];
+    // Reconcile on start up
+    await this.reconcileConsumers();
+  }
+
+  /** Create a new pulse consumer for a hook */
+  async createListener(hook) {
+    this.hook = hook;
+    const client =  this.client;
+    const queueName = `${hook.hookGroupId}/${hook.hookId}`; // serves as unique id for every listener
+    const listener = await pulse.consume({
+      client,
+      queueName,
+      maxLength : 50,
+    }, async ({payload}) => {
+      const hook = this.hook;
+      // Fire the hook
+      await this.taskcreator.fire(hook, {firedBy:'pulseMessage', payload});
+    });
+    this.listeners.push(listener);
+  }
+
+  /** Deletes the amqp queue if it exists for a real pulse client */
+  async deleteQueue(queueName) {
+    if (!this.client.isFakeClient) {
+      if (await this.client.withChannel(async channel => channel.checkQueue(queueName))) {
+        await this.client.withChannel(async channel => channel.deleteQueue(queueName));
+      }
+    }
+  }
+  
+  /** Add / Remove bindings from he queue */
+  async syncBindings(queueName, newBindings, oldBindings) {
+    debug(`Updating the bindings of ${queueName}`);
+    if (!this.client.isFakeClient) {
+      let intersection = _.intersectionWith(oldBindings, newBindings, _.isEqual);
+      oldBindings = _.differenceWith(oldBindings, intersection, _.isEqual);
+      newBindings = _.differenceWith(newBindings, intersection, _.isEqual);
+      for (let {exchange, routingKeyPattern} of oldBindings) {
+        await this.client.withChannel(async channel => channel.unbindQueue(queueName, exchange, routingKeyPattern));
+      }
+      for (let {exchange, routingKeyPattern} of newBindings) {
+        await this.client.withChannel(async channel => channel.bindQueue(queueName, exchange, routingKeyPattern));
+      }
+    }
+  }
+
+  _synchronise(asyncfunc) {
+    return this._reconcileDone = this._reconcileDone.then(asyncfunc).catch(() => {});
+  }
+
+  reconcileConsumers() {
+    return this._synchronise(async () => {
+      let Queues = [];
+      await this.Queues.scan(
+        {},
+        {
+          limit: 1000,
+          handler:(queue) => Queues.push(queue),
+        }
+      );
+      
+      await this.Hook.scan({}, {
+        limit: 1000,
+        handler: async (hook) => {
+          if (hook.bindings.length != 0) {
+            const {hookGroupId, hookId} = hook;
+            const queue = _.find(Queues, {hookGroupId, hookId});
+            if (queue) {
+              const index = this.listeners.findIndex(({_queueName}) => _queueName === queue.queueName);
+              if (index == -1) {
+                debug('Existing queue..creating listener');
+                await this.createListener(hook);
+              }
+              _.pull(Queues, queue);
+              // update the bindings of the queue to be in sync with that in the Hooks table
+              await this.syncBindings(queue.queueName, hook.bindings, queue.bindings);
+              // update the bindings in the Queues Azure table
+              await queue.modify((queue) => {
+                queue.bindings = hook.bindings;
+              });
+            } else {
+              debug('New queue..creating listener');
+              await this.createListener(hook);
+              const queueName = `${hookGroupId}/${hookId}`;
+              await this.syncBindings(queueName, hook.bindings, []);
+              // Add to Queues table
+              debug('Adding to Queues table');
+              await this.Queues.create({
+                hookGroupId,
+                hookId,
+                queueName: `${hookGroupId}/${hookId}`,
+                bindings: hook.bindings,
+              });
+            }
+          }
+        },
+      });
+    
+      // Delete the queues now left in the Queues list.
+      Queues.forEach(async (queue) => {  
+        // Delete the amqp queue
+        await this.deleteQueue(queue.queueName);
+        // Delete from this.listeners
+        let removeIndex = this.listeners.findIndex(({_queueName}) => queue.queueName === _queueName);
+        if (removeIndex > -1) {
+          const listener = this.listeners[removeIndex];
+          listener.stop();
+          this.listeners.splice(removeIndex, 1);
+        }
+        await queue.remove();
+      });
+    });
+  }
+
+  async terminate() {
+    debug('Deleting all queues..');
+    await this.Queues.scan(
+      {},
+      {
+        limit: 1000,
+        handler: async (queue) => {
+          // Delete the amqp queue
+          await this.deleteQueue(queue.queueName);
+          await queue.remove();
+        },
+      }
+    );
+
+    // stop all consumers instead
+    if (!this.client.isFakeClient) {
+      this.listeners.forEach((consumer) => {
+        consumer.stop();
+      });
+    }
+    this.listeners = null;
+  }
+}
+
+module.exports = HookListeners;
diff --git a/src/main.js b/src/main.js
index 65aed8f..de4d31d 100644
--- a/src/main.js
+++ b/src/main.js
@@ -14,7 +14,10 @@ const App = require('taskcluster-lib-app');
 const docs = require('taskcluster-lib-docs');
 const monitor = require('taskcluster-lib-monitor');
 const taskcluster = require('taskcluster-client');
-const {sasCredentials} = require('taskcluster-lib-azure'); 
+const {sasCredentials} = require('taskcluster-lib-azure');
+const exchanges = require('./exchanges');
+const HookListeners = require('./listeners');
+const pulse = require('taskcluster-lib-pulse');
 
 // Create component loader
 const load = loader({
@@ -64,6 +67,18 @@ const load = loader({
     },
   },
 
+  publisher: {
+    requires: ['cfg', 'schemaset', 'monitor'],
+    setup: async ({cfg, schemaset, monitor}) => exchanges.setup({
+      rootUrl:            cfg.taskcluster.rootUrl,
+      credentials:        cfg.pulse,
+      publish:            cfg.app.publishMetaData,
+      validator:          await schemaset.validator(cfg.taskcluster.rootUrl),
+      aws:                cfg.aws.validator,
+      monitor:            monitor.prefix('publisher'),
+    }),
+  },
+
   taskcreator: {
     requires: ['cfg'],
     setup: ({cfg}) => new taskcreator.TaskCreator(cfg.taskcluster),
@@ -79,10 +94,10 @@ const load = loader({
   },
 
   api: {
-    requires: ['cfg', 'schemaset', 'Hook', 'taskcreator', 'monitor'],
-    setup: ({cfg, schemaset, Hook, taskcreator, monitor}) => builder.build({
+    requires: ['cfg', 'schemaset', 'Hook', 'taskcreator', 'monitor', 'publisher'],
+    setup: ({cfg, schemaset, Hook, taskcreator, monitor, publisher}) => builder.build({
       rootUrl: cfg.taskcluster.rootUrl,
-      context: {Hook, taskcreator},
+      context: {Hook, taskcreator, publisher},
       schemaset,
       publish: cfg.app.publishMetaData,
       aws: cfg.aws.validator,
@@ -90,6 +105,48 @@ const load = loader({
     }),
   },
 
+  Queues: {
+    requires: ['cfg', 'process', 'monitor'],
+    setup: ({cfg, process, monitor}) => {
+      return data.Queues.setup({
+        tableName: cfg.app.queuesTableName,
+        monitor: monitor.prefix('table.queues'),
+        credentials: sasCredentials({
+          accountId: cfg.azure.accountId,
+          tableName: cfg.app.queuesTableName,
+          rootUrl: cfg.taskcluster.rootUrl,
+          credentials: cfg.taskcluster.credentials,
+        }),
+        signingKey: cfg.azure.signingKey,
+      });
+    },
+  },
+
+  pulseclient: {
+    requires: ['cfg', 'monitor'],
+    setup: async ({cfg, monitor}) => {
+      return new pulse.Client({
+        namespace: cfg.pulse.namespace,
+        credentials: pulse.pulseCredentials(cfg.pulse),
+        monitor,
+      });
+    },
+  },
+
+  listeners: {
+    requires: ['Hook', 'taskcreator', 'Queues', 'pulseclient'],
+    setup: async ({Hook, taskcreator, Queues, pulseclient}) => {
+      let Listener = new HookListeners({
+        Hook,
+        Queues,
+        taskcreator,
+        client: pulseclient,
+      });
+      await Listener.setup();
+      return Listener;
+    },
+  },
+
   docs: {
     requires: ['cfg', 'schemaset'],
     setup: ({cfg, schemaset}) => docs.documenter({
diff --git a/src/v1.js b/src/v1.js
index 84bd369..b32dd4f 100644
--- a/src/v1.js
+++ b/src/v1.js
@@ -36,7 +36,7 @@ const builder = new APIBuilder({
     hookGroupId: /^[a-zA-Z0-9-_]{1,64}$/,
     hookId: /^[a-zA-Z0-9-_\/]{1,64}$/,
   },
-  context: ['Hook', 'taskcreator'],
+  context: ['Hook', 'taskcreator', 'publisher'],
 });
 
 module.exports = builder;
@@ -233,7 +233,7 @@ builder.declare({
         {});
     }
   }
-
+  this.publisher.hookCreated({hookGroupId, hookId});
   // Reply with the hook definition
   return res.reply(hookDef);
 });
@@ -295,9 +295,10 @@ builder.declare({
         '{{message}} in {{schedElement}}', {message: err.message, schedElement});
     }
   }
-
+  hookDef.bindings = _.defaultTo(hookDef.bindings, hook.bindings);
   await hook.modify((hook) => {
     hook.metadata          = hookDef.metadata;
+    hook.bindings          = hookDef.bindings;
     hook.task              = hookDef.task;
     hook.triggerSchema     = hookDef.triggerSchema;
     hook.schedule          = schedule;
@@ -306,6 +307,8 @@ builder.declare({
   });
 
   let definition = await hook.definition();
+  this.publisher.hookUpdated({hookGroupId, hookId});
+
   return res.reply(definition);
 });
 
@@ -329,6 +332,7 @@ builder.declare({
 
   // Remove the resource if it exists
   await this.Hook.remove({hookGroupId, hookId}, true);
+  this.publisher.hookDeleted({hookGroupId, hookId});
 
   return res.status(200).json({});
 });
@@ -532,4 +536,3 @@ const triggerHookCommon = async function({req, res, hook, payload, firedBy}) {
       {error: (error || 'unknown').toString()});
   }
 };
-
diff --git a/test/api_test.js b/test/api_test.js
index 87a43c2..d7c8646 100644
--- a/test/api_test.js
+++ b/test/api_test.js
@@ -6,7 +6,9 @@ const helper = require('./helper');
 
 helper.secrets.mockSuite('api_test.js', ['taskcluster'], function(mock, skipping) {
   helper.withHook(mock, skipping);
+  helper.withQueues(mock, skipping);
   helper.withTaskCreator(mock, skipping);
+  helper.withPulse(mock, skipping);
   helper.withServer(mock, skipping);
 
   // Use the same hook definition for everything
@@ -26,6 +28,7 @@ helper.secrets.mockSuite('api_test.js', ['taskcluster'], function(mock, skipping
       },
       additionalProperties: true,
     },
+    bindings: [],
   }, hookDef);
 
   const hookWithHookIds = {
@@ -50,6 +53,7 @@ helper.secrets.mockSuite('api_test.js', ['taskcluster'], function(mock, skipping
     },
     hookId:           'bar',
     hookGroupId:      'foo',
+    bindings:         [],
     metadata: {
       name:           'Unit testing hook',
       description:    'Hook created during unit tests',
@@ -63,6 +67,13 @@ helper.secrets.mockSuite('api_test.js', ['taskcluster'], function(mock, skipping
   const invalidHookDef = _.defaults({
     schedule: ['0 0 3 0 * *'],
   }, hookWithTriggerSchema);
+  const unique = new Date().getTime().toString();
+  const hookWithBindings = _.defaults({
+    bindings: [{exchange: `exchanges/test/${unique}`, routingKeyPattern: 'amongst.rockets.wizards'}],
+  }, hookWithHookIds);
+  const hookWithNewBindings = _.defaults({
+    bindings: [{exchange: `exchanges/test-new/${unique}`, routingKeyPattern: 'amongst.new.rockets.and.wizards'}],
+  }, hookWithHookIds);  
 
   const setHookLastFire = async (hookGroupId, hookId, lastFire) => {
     const hook = await helper.Hook.load({hookGroupId, hookId}, true);
@@ -84,12 +95,16 @@ helper.secrets.mockSuite('api_test.js', ['taskcluster'], function(mock, skipping
       const r1 = await helper.hooks.createHook('foo', 'bar', hookWithTriggerSchema);
       const r2 = await helper.hooks.hook('foo', 'bar');
       assume(r1).deep.equals(r2);
+      helper.checkNextMessage('hook-created', ({payload}) =>
+        assume({hookGroupId: 'foo', hookId: 'bar'}).deep.equals(payload));
     });
 
     test('creates a hook with slash in hookId', async () => {
       const r1 = await helper.hooks.createHook('foo', 'bar/slash', hookWithTriggerSchema);
       const r2 = await helper.hooks.hook('foo', 'bar/slash');
       assume(r1).deep.equals(r2);
+      helper.checkNextMessage('hook-created', ({payload}) =>
+        assume({hookGroupId: 'foo', hookId: 'bar/slash'}).deep.equals(payload));
     });
 
     test('with invalid scopes', async () => {
@@ -195,6 +210,8 @@ helper.secrets.mockSuite('api_test.js', ['taskcluster'], function(mock, skipping
       const r2 = await helper.hooks.updateHook('foo', 'bar', inputWithTriggerSchema);
       assume(r2.metadata).deep.not.equals(r1.metadata);
       assume(r2.task).deep.equals(r1.task);
+      helper.checkNextMessage('hook-updated', ({payload}) =>
+        assume({hookId: 'bar', hookGroupId: 'foo'}).deep.equals(payload));
     });
 
     test('fails if resource doesn\'t exist', async () => {
@@ -231,6 +248,8 @@ helper.secrets.mockSuite('api_test.js', ['taskcluster'], function(mock, skipping
       await helper.hooks.hook('foo', 'bar').then(
         () => { throw new Error('The resource should not exist'); },
         (err) => { assume(err.statusCode).equals(404); });
+      helper.checkNextMessage('hook-deleted', ({payload}) =>
+        assume({hookGroupId: 'foo', hookId: 'bar'}).deep.equals(payload));
     });
 
     test('removed empty groups', async () => {
@@ -583,4 +602,106 @@ helper.secrets.mockSuite('api_test.js', ['taskcluster'], function(mock, skipping
       }]);
     });
   });
+
+  suite('pulseHooks', function() {
+    subSkip();
+    test('creates hook', async () => {
+      const r1 = await helper.hooks.createHook('foo', 'bar', hookWithBindings);
+      const r2 = await helper.hooks.hook('foo', 'bar');
+      assume(r1).deep.equals(r2);
+      helper.checkNextMessage('hook-created', ({payload}) =>
+        assume({hookGroupId: 'foo', hookId: 'bar'}).deep.equals(payload));
+    });
+
+    test('hook-created message reconciles consumers', async () => {
+      await helper.hooks.createHook('foo', 'bar', hookWithBindings);
+      let reconcileConsumers = false;
+      helper.Listener.reconcileConsumers = async () => reconcileConsumers = true;
+      await helper.Listener.pulseHookChangedListener.fakeMessage({
+        payload: {
+          hookId:'bar',
+          hookGroupId:'foo',
+        }, exchange:'exchange/taskcluster-hooks/v1/hook-created',
+      });
+      assert(reconcileConsumers);
+    });
+
+    test('hook-created message creates a new listener', async () => {
+      const r1 = await helper.hooks.createHook('foo', 'bar', hookWithBindings);
+      let createdListener = false;
+      helper.Listener.createListener = async (hook) => {
+        if (hook.hookId==='bar' && hook.hookGroupId==='foo' && _.isEqual(hook.bindings, r1.bindings)) {
+          createdListener = true;
+        }
+      };
+      await helper.Listener.pulseHookChangedListener.fakeMessage({
+        payload: {
+          hookId:'bar',
+          hookGroupId:'foo',
+        }, exchange:'exchange/taskcluster-hooks/v1/hook-created',
+      });
+      assert(createdListener);
+      const queue = await helper.Queues.load({hookGroupId: 'foo', hookId: 'bar'}, true);
+      assume(queue.bindings).deep.equals(r1.bindings);
+    });
+
+    test('triggers hook with a pulse message', async () => {
+      const r1 = await helper.hooks.createHook('foo', 'bar', hookWithBindings);
+      await helper.Listener.pulseHookChangedListener.fakeMessage({
+        payload: {
+          hookId:'bar',
+          hookGroupId:'foo',
+        }, exchange:'exchange/taskcluster-hooks/v1/hook-created',
+      });
+      let listener = _.last(helper.Listener.listeners);
+      await listener.fakeMessage({payload:{location: 'Orlando'}, exchange: r1.bindings[0].exchange});
+      assume(helper.creator.fireCalls).deep.equals([{
+        hookGroupId: 'foo',
+        hookId: 'bar',
+        context: {firedBy: 'pulseMessage', payload: {location: 'Orlando'}},
+        options: {},
+      }]);
+    });
+
+    test('updating a hook updates bindings of queue', async () => {
+      await helper.hooks.createHook('foo', 'bar', hookWithBindings);
+      await helper.Listener.pulseHookChangedListener.fakeMessage({
+        payload: {
+          hookId:'bar',
+          hookGroupId:'foo',
+        }, exchange:'exchange/taskcluster-hooks/v1/hook-created',
+      });
+      const r1 = await helper.hooks.updateHook('foo', 'bar', hookWithNewBindings);
+      await helper.Listener.pulseHookChangedListener.fakeMessage({
+        payload: {
+          hookId:'bar',
+          hookGroupId:'foo',
+        }, exchange:'exchange/taskcluster-hooks/v1/hook-updated',
+      });
+      const queue = await helper.Queues.load({hookGroupId: 'foo', hookId: 'bar'}, true);
+      assume(queue.bindings).deep.equals(r1.bindings);
+    });
+
+    test('removing a hook removes the queue', async () => {
+      const r1 = await helper.hooks.createHook('foo', 'bar', hookWithBindings);
+      await helper.Listener.pulseHookChangedListener.fakeMessage({
+        payload: {
+          hookId:'bar',
+          hookGroupId:'foo',
+        }, exchange:'exchange/taskcluster-hooks/v1/hook-created',
+      });
+      let queue = await helper.Queues.load({hookGroupId: 'foo', hookId: 'bar'}, true);
+      assume(queue.bindings).deep.equals(r1.bindings);
+      await helper.hooks.removeHook('foo', 'bar');
+      await helper.Listener.pulseHookChangedListener.fakeMessage({
+        payload: {
+          hookId:'bar',
+          hookGroupId:'foo',
+        }, exchange:'exchange/taskcluster-hooks/v1/hook-deleted',
+      });
+      queue = await helper.Queues.load({hookGroupId: 'foo', hookId: 'bar'}, true);
+      assert.equal(queue, null);
+    });
+  });
+
 });
diff --git a/test/helper.js b/test/helper.js
index 7282de0..6bbed84 100644
--- a/test/helper.js
+++ b/test/helper.js
@@ -2,10 +2,13 @@ const data = require('../src/data');
 const taskcluster = require('taskcluster-client');
 const taskcreator = require('../src/taskcreator');
 const {stickyLoader, fakeauth, Secrets} = require('taskcluster-lib-testing');
-const builder = require('../src/v1');
+const {builder} = require('../src/v1');
 const load = require('../src/main');
 const config = require('typed-env-config');
 const _ = require('lodash');
+const libUrls = require('taskcluster-lib-urls');
+const {FakeClient} = require('taskcluster-lib-pulse');
+const HookListeners = require('../src/listeners');
 
 const helper = module.exports = {};
 
@@ -14,6 +17,7 @@ helper.rootUrl = 'http://localhost:60401';
 helper.load = stickyLoader(load);
 helper.load.inject('profile', 'test');
 helper.load.inject('process', 'test');
+helper.load.inject('pulseclient', new FakeClient());
 
 helper.secrets = new Secrets({
   secretName: 'project/taskcluster/testing/taskcluster-hooks',
@@ -22,7 +26,7 @@ helper.secrets = new Secrets({
     taskcluster: [
       {env: 'TASKCLUSTER_CLIENT_ID', cfg: 'taskcluster.credentials.clientId', name: 'clientId'},
       {env: 'TASKCLUSTER_ACCESS_TOKEN', cfg: 'taskcluster.credentials.accessToken', name: 'accessToken'},
-      {env: 'TASKCLUSTER_ROOT_URL', cfg: 'taskcluster.rootUrl', name: 'rootUrl'},
+      {env: 'TASKCLUSTER_ROOT_URL', cfg: 'taskcluster.rootUrl', name: 'rootUrl', mock: libUrls.testRootUrl()},
     ],
   },
 });
@@ -52,7 +56,7 @@ helper.withHook = (mock, skipping) => {
 
   const cleanup = async () => {
     if (!skipping()) {
-      await helper.Hook.scan({}, {handler: hook => hook.remove()});
+      await helper.Hook.scan({}, {handler: async (hook) => { await hook.remove();}});
     }
   };
   setup(cleanup);
@@ -84,6 +88,105 @@ helper.withTaskCreator = function(mock, skipping) {
 };
 
 /**
+ * Set up PulsePublisher in fake mode, at helper.publisher. Messages are stored
+ * in helper.messages.  The `helper.checkNextMessage` function allows asserting the
+ * content of the next message, and `helper.checkNoNextMessage` is an assertion that
+ * no such message is in the queue.
+ */
+helper.withPulse = (mock, skipping) => {
+  let Listener;
+  suiteSetup(async function() {
+    if (skipping()) {
+      return;
+    }
+
+    await helper.load('cfg');
+    helper.load.cfg('pulse', {fake: true});
+    helper.publisher = await helper.load('publisher');
+    helper.checkNextMessage = (exchange, check) => {
+      for (let i = 0; i < helper.messages.length; i++) {
+        const message = helper.messages[i];
+        // skip messages for other exchanges; this allows us to ignore
+        // ordering of messages that occur in indeterminate order
+        if (!message.exchange.endsWith(exchange)) {
+          continue;
+        }
+        check && check(message);
+        helper.messages.splice(i, 1); // delete message from queue
+        return;
+      }
+      throw new Error(`No messages found on exchange ${exchange}; ` +
+        `message exchanges: ${JSON.stringify(helper.messages.map(m => m.exchange))}`);
+    };
+
+    helper.checkNoNextMessage = exchange => {
+      assert(!helper.messages.some(m => m.exchange.endsWith(exchange)));
+    };
+  });
+
+  const fakePublish = msg => { helper.messages.push(msg); };
+  setup(async function() {
+    helper.messages = [];
+    helper.publisher.on('fakePublish', fakePublish);
+    if (helper.Listener) {
+      await helper.Listener.terminate();
+      helper.Listener = null;
+    }
+    let Hook = await helper.load('Hook');
+    let Queues = await helper.load('Queues');
+    let taskcreator = await helper.load('taskcreator');
+    
+    helper.Listener = new HookListeners({
+      Hook,
+      Queues,
+      taskcreator,
+      client: new FakeClient(),
+    });
+
+    await helper.Listener.setup();
+  });
+
+  suiteTeardown(async function() {
+    helper.publisher.removeListener('fakePublish', fakePublish);
+    if (helper.Listener) {
+      await helper.Listener.terminate();
+      helper.Listener = null;
+    }
+  });
+};
+
+/**
+ * Set helper.Queues to a set-up Queues entity (and inject it into the loader)
+ */
+helper.withQueues = (mock, skipping) => {
+  suiteSetup(async function() {
+    if (skipping()) {
+      return;
+    }
+
+    if (mock) {
+      const cfg = await helper.load('cfg');
+      helper.load.inject('Queues', data.Queues.setup({
+        tableName: cfg.app.queuesTableName,
+        credentials: 'inMemory',
+        signingKey: cfg.azure.signingKey,
+      }));
+    }
+
+    helper.Queues = await helper.load('Queues');
+    await helper.Queues.ensureTable();
+  });
+
+  const cleanup = async () => {
+    if (!skipping()) {
+      await helper.Queues.scan({}, {handler: async (queue) => await queue.remove()});
+    }
+  };
+  setup(cleanup);
+  suiteTeardown(cleanup);
+};
+
+/**
  * Set up an API server.  Call this after withHook, so the server
  * uses the same Hook class.
  *
diff --git a/user-config-example.yml b/user-config-example.yml
index d34fb43..781bb11 100644
--- a/user-config-example.yml
+++ b/user-config-example.yml
@@ -5,3 +5,8 @@ test:
     credentials:
       clientId:       '...'
       accessToken:    '...'
+  pulse:
+    username:                 '...'
+    password:                 '...'
+    hostname:                 '...'
+    vhost:                    '...'
diff --git a/yarn.lock b/yarn.lock
index 9ef5dac..6b5fff6 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -56,7 +56,7 @@ ajv@^5.1.0, ajv@^5.2.3, ajv@^5.3.0:
     fast-json-stable-stringify "^2.0.0"
     json-schema-traverse "^0.3.0"
 
-amqplib@^0.5.1:
+amqplib@^0.5.1, amqplib@^0.5.2:
   version "0.5.2"
   resolved "https://registry.yarnpkg.com/amqplib/-/amqplib-0.5.2.tgz#d2d7313c7ffaa4d10bcf1e6252de4591b6cc7b63"
   dependencies:
@@ -161,6 +161,13 @@ assume@^1.2.5, assume@^1.5.2:
     pathval "0.1.x"
     pruddy-error "1.0.x"
 
+async-decorators@^0.1.5:
+  version "0.1.5"
+  resolved "https://registry.yarnpkg.com/async-decorators/-/async-decorators-0.1.5.tgz#23fcbfdd45b668b53d1f4e5ff4b2951552021d95"
+  integrity sha1-I/y/3UW2aLU9H05f9LKVFVICHZU=
+  dependencies:
+    lodash "^3.10.1"
+
 async@^2.4.0:
   version "2.6.0"
   resolved "https://registry.yarnpkg.com/async/-/async-2.6.0.tgz#61a29abb6fcc026fea77e56d1c6ec53a795951f4"
@@ -201,6 +208,20 @@ aws-sdk@^2.144.0, aws-sdk@^2.147.0, aws-sdk@^2.151.0, aws-sdk@^2.164.0:
     xml2js "0.4.17"
     xmlbuilder "4.2.1"
 
+aws-sdk@^2.148.0:
+  version "2.315.0"
+  resolved "https://registry.yarnpkg.com/aws-sdk/-/aws-sdk-2.315.0.tgz#7f393162af038cbef722374444a9bc9ae1bdbbe9"
+  dependencies:
+    buffer "4.9.1"
+    events "1.1.1"
+    ieee754 "1.1.8"
+    jmespath "0.15.0"
+    querystring "0.2.0"
+    sax "1.2.1"
+    url "0.10.3"
+    uuid "3.1.0"
+    xml2js "0.4.19"
+
 aws-sign2@~0.6.0:
   version "0.6.0"
   resolved "https://registry.yarnpkg.com/aws-sign2/-/aws-sign2-0.6.0.tgz#14342dd38dbcc94d0e5b87d763cd63612c0e794f"
@@ -802,7 +823,7 @@ etag@~1.8.1:
   version "1.8.1"
   resolved "https://registry.yarnpkg.com/etag/-/etag-1.8.1.tgz#41ae2eeb65efa62268aebfea83ac7d79299b0887"
 
-events@^1.1.1:
+events@1.1.1, events@^1.1.1:
   version "1.1.1"
   resolved "https://registry.yarnpkg.com/events/-/events-1.1.1.tgz#9ebdb7635ad099c70dcc4c2a1f5004288e8bd924"
 
@@ -1214,7 +1235,7 @@ iconv-lite@0.4.19, iconv-lite@^0.4.17:
   version "0.4.19"
   resolved "https://registry.yarnpkg.com/iconv-lite/-/iconv-lite-0.4.19.tgz#f7468f60135f5e5dad3399c0a81be9a1603a082b"
 
-ieee754@^1.1.4:
+ieee754@1.1.8, ieee754@^1.1.4:
   version "1.1.8"
   resolved "https://registry.yarnpkg.com/ieee754/-/ieee754-1.1.8.tgz#be33d40ac10ef1926701f6f08a2d86fbfd1ad3e4"
 
@@ -1452,6 +1473,11 @@ lodash@4.17.4, lodash@^4.0.0, lodash@^4.13.1, lodash@^4.14.0, lodash@^4.15.0, lo
   version "4.17.4"
   resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.4.tgz#78203a4d1c328ae1d86dca6460e369b57f4055ae"
 
+lodash@^3.10.1:
+  version "3.10.1"
+  resolved "https://registry.yarnpkg.com/lodash/-/lodash-3.10.1.tgz#5bf45e8e49ba4189e17d482789dfd15bd140b7b6"
+  integrity sha1-W/Rejkm6QYnhfUgnid/RW9FAt7Y=
+
 lowercase-keys@^1.0.0:
   version "1.0.0"
   resolved "https://registry.yarnpkg.com/lowercase-keys/-/lowercase-keys-1.0.0.tgz#4e3366b39e7f5457e35f1324bdf6f88d0bfc7306"
@@ -1824,6 +1850,20 @@ pseudomap@^1.0.2:
   version "1.0.2"
   resolved "https://registry.yarnpkg.com/pseudomap/-/pseudomap-1.0.2.tgz#f052a28da70e618917ef0a8ac34c1ae5a68286b3"
 
+pulse-publisher@^10.0.1:
+  version "10.0.1"
+  resolved "https://registry.yarnpkg.com/pulse-publisher/-/pulse-publisher-10.0.1.tgz#db150103f87a0b508374fa0949191a6fead56db0"
+  dependencies:
+    ajv "^5.3.0"
+    amqplib "^0.5.1"
+    aws-sdk "^2.148.0"
+    debug "^3.1.0"
+    lodash "^4.0.0"
+    promise "^8.0.1"
+    slugid "^1.1.0"
+    taskcluster-client "^10.0.0"
+    taskcluster-lib-urls "^10.0.0"
+
 punycode@1.3.2:
   version "1.3.2"
   resolved "https://registry.yarnpkg.com/punycode/-/punycode-1.3.2.tgz#9653a036fb7c1ee42342f2325cceefea3926c48d"
@@ -2324,6 +2364,19 @@ taskcluster-client@^11.0.0:
     superagent "~3.8.1"
     taskcluster-lib-urls "^10.0.0"
 
+taskcluster-client@^11.0.4:
+  version "11.0.4"
+  resolved "https://registry.yarnpkg.com/taskcluster-client/-/taskcluster-client-11.0.4.tgz#ea8df77d78ac72de5fb087bb6b884a25f33c90ee"
+  dependencies:
+    amqplib "^0.5.1"
+    debug "^3.1.0"
+    hawk "^6.0.2"
+    lodash "^4.17.4"
+    promise "^8.0.1"
+    slugid "^1.1.0"
+    superagent "~3.8.1"
+    taskcluster-lib-urls "^10.0.0"
+
 taskcluster-client@^3.0.3:
   version "3.1.1"
   resolved "https://registry.yarnpkg.com/taskcluster-client/-/taskcluster-client-3.1.1.tgz#8420c269146d4be0774a49e6685a972d3ae40c59"
@@ -2430,6 +2483,15 @@ taskcluster-lib-monitor@^10.0.0:
     statsum "^0.6.0"
     taskcluster-client "^10.0.0"
 
+taskcluster-lib-pulse@^2.0.2:
+  version "2.0.2"
+  resolved "https://registry.yarnpkg.com/taskcluster-lib-pulse/-/taskcluster-lib-pulse-2.0.2.tgz#1720678ae0f0a6ead02c8b1a816be163cb533826"
+  dependencies:
+    amqplib "^0.5.2"
+    debug "^3.1.0"
+    taskcluster-client "^11.0.4"
+    taskcluster-lib-urls "^10.0.0"
+
 taskcluster-lib-scopes@^10.0.0:
   version "10.0.0"
   resolved "https://registry.yarnpkg.com/taskcluster-lib-scopes/-/taskcluster-lib-scopes-10.0.0.tgz#2b90666b8e5127a1d367b726de84c7829b57efef"
@@ -2686,12 +2748,23 @@ xml2js@0.4.17:
     sax ">=0.6.0"
     xmlbuilder "^4.1.0"
 
+xml2js@0.4.19:
+  version "0.4.19"
+  resolved "https://registry.yarnpkg.com/xml2js/-/xml2js-0.4.19.tgz#686c20f213209e94abf0d1bcf1efaa291c7827a7"
+  dependencies:
+    sax ">=0.6.0"
+    xmlbuilder "~9.0.1"
+
 xmlbuilder@4.2.1, xmlbuilder@^4.1.0:
   version "4.2.1"
   resolved "https://registry.yarnpkg.com/xmlbuilder/-/xmlbuilder-4.2.1.tgz#aa58a3041a066f90eaa16c2f5389ff19f3f461a5"
   dependencies:
     lodash "^4.0.0"
 
+xmlbuilder@~9.0.1:
+  version "9.0.7"
+  resolved "https://registry.yarnpkg.com/xmlbuilder/-/xmlbuilder-9.0.7.tgz#132ee63d2ec5565c557e20f4c22df9aca686b10d"
+
 xtend@^4.0.0, xtend@^4.0.1, xtend@~4.0.1:
   version "4.0.1"
   resolved "https://registry.yarnpkg.com/xtend/-/xtend-4.0.1.tgz#a5c6d532be656e23db820efb943a1f04998d63af"
